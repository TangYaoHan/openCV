                                  笔记
1. 什么是特征？
    特征 = 像素 + 运算  —>> 结果 （具体值，向量， 矩阵， 多维）
2. 如何进行目标检测？
    (1) 如何利用特征区分目标？  阈值判决
    (2) 得到判决？    机器学习
3. 步骤： 1.特征  2. 判决  3. 获取判决

4.公式推导：
    Haar basic特征（模板: 上半全黑， 下半全白）：
        特征 = 白色 - 黑色
        等价于：特征 = 整个区域*权重1 +黑色*权重2  （权重1=1，  权重2 = -2）
        等价于： 特征 = （p1 - p2 -p3 + p4）* w     (积分图)

5.Haar检测过程
    Haar模板 上下  左右移动     image size（100*100） 和 模板size（10*10） step=10
    即   1. 100*100   2. 10*10  3 step: 10      （仅一个模板的计算过程）
    模板   滑动、 缩放    10*10 -》 11*11    20级
6.举例： 1080*720  step：2   模板：10*10
    计算量 = 14个模板*20缩放*（1080/2*720/2）*（100点 +-操作） = 50 -100 亿次
    （50 - 100）亿  * 15 = 1000亿  完成整张图的Haar特征检测

7. 积分图减少计算量（任意像素值计算都可以转化为：三次加减法）
    [1:A   2:B           计算方式： 1 = A    2 = A+B
     3:C   4:D]                    3 = A+C  4 = A+B+C+D
     如： 4号区域像素值 = D - B - C + A = D - (A+B) - (A+C) + A

8. adaboost分类器
    如：  苹果  苹果   苹果   香蕉
           01.  0.1   0.1    0.5
    训练终止条件： 1. max count   2. 概率p大于设定的阈值

9. 分类器的结果
    1. 分类器结构：
        （1）强分类器
        x1(haar) > T1  and  x2(haar) > T2  and ...  一般需要通过15-20个强分类器才判定为目标
        Tn: 阈值，通过训练获得   xn:强分类器特征
        一个强分类器可以分为多个弱分类器， 一个若分类器可以分为多个Node
        （2）弱分类器：
        作用：计算强分类器特征 x1, x2, x3...
        计算： 每个强分类器特征xn = y1 + y2 + y3....
        (3）Node：
            openCV最多支持3个haar特征，   一个haar特征 <=> 一个node
            node_1:
                    haar_1 > node_T1    z1 = a1
                    haar_1 < node_T1    z1 = a2
             z = sum(z1, z2, z3) > T    y1 = AA   （弱分类器的值）
             z = sum(z1, z2, z3) < T    y1 = BB
         (4)总结：
            z = sum(z1, z2, z3)  > 或者 <  阈值Ty   ->  y1(y2, y3...同理)
            x1 = sum(y1, y2, y3,...)  > 阈值Tx  (x2, x3, ...同理)
            finaly： object

    2. adaboost训练过程
        （1）初始化数据权值分布
                苹果（0.1）   苹果（0.1）  苹果（0.1）  香蕉（0.1）
        （2）遍历阈值p， 计算误差概率 min(p)  和 权值  t
        （3）计算权重系数 G1（x）
        （4）更新权值分布 update    如：  0.2  0.2  0.2  0.7  (苹果同类相同，香蕉错误的目标被加强)
        （5）训练终止：循环次数最大  或者   误差概率小于设定的阈值
    3. xml文件结构
        openCV源码中（两个）， 已经训练好的分类器，解析过程也由openCV处理

10. SVM(支持向量机)：分类器
    本质：寻求一个最优的超平面， 完成分类
    方法：line 或者曲线
    例如：身高体重完成男女分类       训练 -》 预测

11. Hog特征
    （1）什么是Hog特征？     特征： 某个像素 某种运算的结果
    （2） 过程：
            1）模块划分：  image  ->   window窗体  ->  block ->  cell
                window窗体：特征计算最顶层单元   size: 任意   64*128（行人检测，车辆识别官方推荐）
                block: 一般window窗体是block width和height的整数倍(64*128 可以采用 16*16的block)
                block step:block在window窗体上滑动的步长（16*16的block对应  8*8的step）
                计算block: count = ((64-16)/8+1) *(128-16)/8+1) = 105 block  （注意两个16和8分别是宽高上，并不总是相等）
                cell: size: 8*8(参考16*16block)
                16*16 block = 4  8*8 cell    (4个cell)
                bin: 与cell相关   梯度：运算     每个像素  ->  梯度：  大小 f  方向 angle
                    0-360°/40 = 9块 bin   《=》   1 bin = 40°
                    1 cell =  360°   《=》   9 bin
                hog特征的维度(haar：值)：hog: 向量 -> 完全描述obj的全部信息
                    维度 = 105 * 4 * 9 = 3780 （block*cell*bin）
            2）梯度、方向、模板
                window窗体中全部像素 -> 每个像素都有梯度 -> hog
                特征模板：
                    水平方向：[1  0  -1]         a = p1*1+p2*0+p3*-1 = 相邻像素之差
                    垂直方向：[[1], [0], [-1]]   b = 上下像素之差
                    幅值 f = 开根号（a平方 + b平方）
                    角度 angle = arctan(a/b)
            3）bin投影
                bin: 0-360  -> 9 bin -> 0-40
                备注：40°并不是连续的。  如 bin1： 0-20  +  180-200 （对称）
                像素ij： 梯度f  角度a=10   ->  0-20的center  -> 落在bin1上
                                角度a=25  ->  bin1 and bin2
                                    f1 = f*f(夹角)  f2=f*(1-f(夹角))   f（夹角）∈[0,1.0]
            4) 整体Hog  cell复用
                3780    《《    win  block  cell  bin
                1 >> bin     block  << cell0, cell1, cell2, cell4
                    cell0:  bin0  bin1 ...  bin8
                    cell1:  bin0  bin1 ...  bin8
                    cell2:  bin0  bin1 ...  bin8
                    cell3:  bin0  bin1 ...  bin8
                （i，j）像素：投影在  cell0的bin0   ->>  梯度（f 和 a）
                （i_1, j）像素：投影在  cell0的bin0  ->> f1
                ....................
                sumbin0(f0+fi) = bin0

                # cell复用
                [cell0]  [cell1] [cell2] [cell3]
    Hog判决：  hog[3780] * svm line train[3780]
        hog*svm > T   即为obj， 否则为非obj



